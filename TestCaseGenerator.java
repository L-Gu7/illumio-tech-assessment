// Generated by Claude 3.5 Sonnet
// Adapted to fit project structure and actual cases

import java.io.*;
import java.util.*;
import java.time.Instant;

public class TestCaseGenerator {
    private final List<String> protocolKeywords = new ArrayList<>();
    private final Random random = new Random();
    private static final String[] TAG_PREFIXES = {"sv_P", "sv_DB", "sv_NET", "sv_SEC"};

    // Common ports for realistic distribution
    private static final int[] COMMON_PORTS = {
            20, 21, 22, 23, 25, 53, 80, 110, 143, 443, 465, 587, 993, 995, 3306, 3389, 5432, 8080, 8443
    };

    public void loadProtocols(String filename) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            boolean firstLine = true;
            while ((line = br.readLine()) != null) {
                if (firstLine) {
                    firstLine = false;
                    continue;
                }
                String[] parts = line.split(",");
                if (parts.length >= 2 && parts[0].matches("\\d+") && !parts[1].isEmpty()) {
                    protocolKeywords.add(parts[1].trim().toLowerCase());
                }
            }
        }
        System.out.println("Loaded " + protocolKeywords.size() + " protocols");
    }

    public void generateLookupTable(String filename, int numMappings) throws IOException {
        System.out.println("Generating lookup table...");
        Set<String> usedCombinations = new HashSet<>();

        try (PrintWriter writer = new PrintWriter(new FileWriter(filename))) {
            writer.println("dstport,protocol,tag");

            int generated = 0;
            while (generated < numMappings) {
                int port;
                if (random.nextDouble() < 0.7) { // 70% chance of common port
                    port = COMMON_PORTS[random.nextInt(COMMON_PORTS.length)];
                } else {
                    port = random.nextInt(65536);
                }

                String protocol = protocolKeywords.get(random.nextInt(protocolKeywords.size()));
                String tag = generateTag();

                String combination = port + "," + protocol;
                if (!usedCombinations.contains(combination)) {
                    writer.println(port + "," + protocol + "," + tag);
                    usedCombinations.add(combination);
                    generated++;
                }
            }
        }
    }

    private String generateTag() {
        String prefix = TAG_PREFIXES[random.nextInt(TAG_PREFIXES.length)];
        return prefix + (random.nextInt(20) + 1); // Tags from 1 to 20 for each prefix
    }

    public void generateFlowLogs(String filename, int numLogs) throws IOException {
        System.out.println("Generating flow logs...");
        try (PrintWriter writer = new PrintWriter(new FileWriter(filename))) {
            for (int i = 0; i < numLogs; i++) {
                writer.println(generateFlowLogEntry());
            }
        }
    }

    private String generateFlowLogEntry() {
        StringBuilder sb = new StringBuilder();

        // Version (always 2)
        sb.append("2 ");

        // Account ID (12 digits)
        sb.append("123456789012 ");

        // ENI ID (random)
        sb.append("eni-").append(generateRandomHex(8)).append(" ");

        // Source IP (private ranges)
        sb.append(generatePrivateIP()).append(" ");

        // Destination IP (public ranges)
        sb.append(generatePublicIP()).append(" ");

        // Source port (random)
        sb.append(random.nextInt(65536)).append(" ");

        // Destination port (weighted towards common ports)
        if (random.nextDouble() < 0.8) { // 80% chance of common port
            sb.append(COMMON_PORTS[random.nextInt(COMMON_PORTS.length)]).append(" ");
        } else {
            sb.append(random.nextInt(65536)).append(" ");
        }

        // Protocol number (random index in loaded protocols)
        sb.append(random.nextInt(protocolKeywords.size())).append(" ");

        // Packets
        sb.append(random.nextInt(1000)).append(" ");

        // Bytes
        sb.append(random.nextInt(1000000)).append(" ");

        // Start time (within last hour)
        long now = Instant.now().getEpochSecond();
        long start = now - random.nextInt(3600);
        sb.append(start).append(" ");

        // End time (within 5 minutes of start)
        sb.append(start + random.nextInt(300)).append(" ");

        // Action (mostly ACCEPT)
        sb.append(random.nextDouble() < 0.9 ? "ACCEPT" : "REJECT").append(" ");

        // Status (always OK)
        sb.append("OK");

        return sb.toString();
    }

    private String generateRandomHex(int length) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append(Integer.toHexString(random.nextInt(16)));
        }
        return sb.toString();
    }

    private String generatePrivateIP() {
        int type = random.nextInt(3);
        return switch (type) {
            case 0 -> "10." + random.nextInt(256) + "." +
                    random.nextInt(256) + "." + random.nextInt(256);
            case 1 -> "172." + (16 + random.nextInt(16)) + "." +
                    random.nextInt(256) + "." + random.nextInt(256);
            default -> "192.168." + random.nextInt(256) + "." +
                    random.nextInt(256);
        };
    }

    private String generatePublicIP() {
        while (true) {
            int first = random.nextInt(256);
            if (first != 10 && first != 127 && first != 169 &&
                    first != 172 && first != 192) {
                return first + "." + random.nextInt(256) + "." +
                        random.nextInt(256) + "." + random.nextInt(256);
            }
        }
    }

    public static void main(String[] args) {
        int numMappings, numLogs;
        if (args.length >= 2) {
            numMappings = Integer.parseInt(args[0]);
            numLogs = Integer.parseInt(args[1]);
        } else {
            numMappings = 10000;
            numLogs = 100000; // Approx. 10M log file
        }

        TestCaseGenerator generator = new TestCaseGenerator();
        try {
            generator.loadProtocols("asset/protocol_numbers_adapted.csv");

            // Generate lookup table entries
            generator.generateLookupTable("test/large_lookup_table.csv", numMappings);

            // Generate flow log entries
            generator.generateFlowLogs("test/large_flow.log", numLogs);

        } catch (IOException e) {
            System.err.println("Error generating test cases: " + e.getMessage());
        }
    }
}